# 规则系统修复总结

## 问题描述

用户报告了多个问题：
1. **无法保存创建的规则** - 新创建的规则无法正确保存到存储中
2. **预设规则无法使用** - 预设规则（如"上厕所"、"喝水"等）无法被选择使用
3. **提前完成任务和暂停会重复记录两次** - 操作被重复记录
4. **"任务完成"和"特殊情况"不可点击** - 某些预设规则无法选择
5. **规则应该是链专属的** - 现在规则是全局的，需要改为链专属

## 问题分析

通过分析日志和代码，发现了以下问题：

### 1. 预设规则ID格式错误
- **问题**：`RuleSelectionDialog.tsx`中的`fetchChainRulesFromAPI`函数返回的是模拟数据
- **错误ID**：使用简单的字符串ID如"1"、"2"
- **正确ID格式**：应该是`rule_1755330816268_ay1816fkh`这样的完整格式

### 2. 规则类型枚举错误
- **问题**：代码中使用了不存在的`ExceptionRuleType.BOTH`和`ExceptionRuleType.EARLY_COMPLETION`
- **正确类型**：只有`PAUSE_ONLY`和`EARLY_COMPLETION_ONLY`两个值

### 3. 规则存储连接问题
- **问题**：预设规则没有连接到实际的规则存储系统
- **影响**：规则无法持久化保存

### 4. 重复记录问题
- **问题**：乐观更新和实际更新都触发了记录
- **原因**：`handleRuleSelect`函数使用了乐观更新机制

### 5. 规则作用域问题
- **问题**：所有规则都是全局的，没有链专属支持
- **影响**：不同链之间的规则混在一起

## 解决方案

### 1. 修复预设规则获取逻辑

**文件**：`src/components/RuleSelectionDialog.tsx`

**修改内容**：
- 将模拟的`fetchChainRulesFromAPI`函数改为从实际的`exceptionRuleManager`获取规则
- 添加默认预设规则创建逻辑
- 修复规则类型过滤逻辑
- 添加链专属规则过滤

```typescript
// 从实际存储获取规则
const fetchChainRulesFromAPI = async (chainId: string, actionType: string): Promise<ExceptionRule[]> => {
  try {
    // 获取所有规则
    const allRules = await exceptionRuleManager.getAllRules();
    
    // 过滤出当前链的规则，并且适用于当前操作类型
    const applicableRules = allRules.filter(rule => {
      // 只显示当前链的规则或全局规则
      const isChainRule = rule.chainId === chainId;
      const isGlobalRule = rule.scope === 'global';
      
      if (!isChainRule && !isGlobalRule) {
        return false;
      }
      
      // 检查规则类型是否匹配
      if (actionType === 'pause') {
        return rule.type === ExceptionRuleType.PAUSE_ONLY;
      } else {
        return rule.type === ExceptionRuleType.EARLY_COMPLETION_ONLY;
      }
    });

    // 如果没有规则，创建一些默认的预设规则
    if (applicableRules.length === 0) {
      const defaultRules = await createDefaultPresetRules(chainId, actionType);
      return defaultRules;
    }

    return applicableRules;
  } catch (error) {
    console.error('获取规则失败:', error);
    return createDefaultPresetRules(chainId, actionType);
  }
};
```

### 2. 添加链专属规则支持

**文件**：`src/services/ExceptionRuleManager.ts`

**新增方法**：
```typescript
/**
 * 创建链专属规则
 */
async createChainRule(
  chainId: string,
  name: string, 
  type: ExceptionRuleType, 
  description?: string
): Promise<{
  rule: ExceptionRule;
  warnings: string[];
}> {
  // 确保初始化
  await this.initialize();

  try {
    // 验证输入
    console.log('🔧 ExceptionRuleManager.createChainRule 验证参数:', { chainId, name, type, description });
    exceptionRuleStorage.validateRule({ name, type, description }, true);

    // 创建链专属规则
    const ruleData: Omit<ExceptionRule, 'id' | 'createdAt' | 'usageCount' | 'isActive'> = {
      name,
      type,
      description,
      chainId,
      scope: 'chain'
    };

    const rule = await exceptionRuleStorage.createRule(ruleData);

    // 验证创建的规则
    const validationResult = await enhancedRuleValidationService.validateRulesIntegrity([rule]);
    if (validationResult.invalidRules.length > 0) {
      console.warn('创建的链专属规则存在问题:', validationResult.invalidRules);
    }

    return {
      rule,
      warnings: []
    };

  } catch (error) {
    if (error instanceof ExceptionRuleException) {
      throw error;
    }
    throw new ExceptionRuleException(
      ExceptionRuleError.STORAGE_ERROR,
      '创建链专属规则失败',
      error
    );
  }
}
```

### 3. 修复重复记录问题

**文件**：`src/components/RuleSelectionDialog.tsx`

**修改内容**：
- 移除乐观更新机制，直接调用父组件回调
- 避免重复触发规则使用记录

```typescript
// 选择规则
const handleRuleSelect = useCallback(async (rule: ExceptionRule) => {
  try {
    console.log('🔧 RuleSelectionDialog 选择规则:', { rule, actionType });
    
    // 直接调用父组件的回调，不使用乐观更新避免重复记录
    if (actionType === 'pause') {
      onRuleSelected(rule, pauseOptions);
    } else {
      onRuleSelected(rule);
    }
  } catch (err) {
    setError(err instanceof Error ? err.message : '选择规则失败');
  }
}, [actionType, pauseOptions, onRuleSelected]);
```

### 4. 修复规则存储重复检查

**文件**：`src/services/ExceptionRuleStorage.ts`

**修改内容**：
- 支持链专属规则的重复检查
- 链专属规则只检查同链内的重复
- 全局规则检查所有全局规则

```typescript
// 验证规则名称唯一性（链专属规则只检查同链内的重复，全局规则检查所有规则）
const existingRules = await this.getRules();
const isDuplicate = existingRules.some(r => {
  if (r.name !== rule.name || !r.isActive) return false;
  
  // 如果是链专属规则，只检查同链内的重复
  if (rule.chainId && r.chainId) {
    return r.chainId === rule.chainId;
  }
  
  // 如果是全局规则，检查所有全局规则
  if (rule.scope === 'global' && r.scope === 'global') {
    return true;
  }
  
  return false;
});

if (isDuplicate) {
  const scopeText = rule.chainId ? '此链中' : '全局';
  throw new ExceptionRuleException(
    ExceptionRuleError.DUPLICATE_RULE_NAME,
    `规则名称 "${rule.name}" 在${scopeText}已存在`
  );
}
```

### 5. 修改规则创建逻辑

**文件**：`src/components/RuleSelectionDialog.tsx`

**修改内容**：
- 用户创建的新规则自动设为链专属
- 默认预设规则也设为链专属

```typescript
// 创建默认预设规则
const createDefaultPresetRules = async (chainId: string, actionType: string): Promise<ExceptionRule[]> => {
  const defaultRuleNames = actionType === 'pause' 
    ? ['上厕所', '喝水', '接电话', '紧急情况']
    : ['任务完成', '提前达成目标', '特殊情况'];
  
  const ruleType = actionType === 'pause' 
    ? ExceptionRuleType.PAUSE_ONLY 
    : ExceptionRuleType.EARLY_COMPLETION_ONLY;

  const createdRules: ExceptionRule[] = [];
  
  for (const name of defaultRuleNames) {
    try {
      // 创建链专属规则
      const result = await exceptionRuleManager.createChainRule(chainId, name, ruleType, `默认${actionType === 'pause' ? '暂停' : '提前完成'}规则`);
      createdRules.push(result.rule);
    } catch (error) {
      console.warn(`创建默认规则 "${name}" 失败:`, error);
    }
  }
  
  return createdRules;
};
```

## 测试验证

创建了测试脚本验证修复效果：

```javascript
// 测试结果
🧪 开始测试链专属规则功能...
🎯 测试链专属规则创建和过滤...

📋 为链1创建规则...
✅ 创建链专属规则: { chainId: 'chain-1', name: '任务完成', type: 'early_completion_only' }
✅ 创建链专属规则: { chainId: 'chain-1', name: '提前达成目标', type: 'early_completion_only' }
✅ 创建链专属规则: { chainId: 'chain-1', name: '特殊情况', type: 'early_completion_only' }

📋 为链2创建规则...
✅ 创建链专属规则: { chainId: 'chain-2', name: '任务完成', type: 'early_completion_only' }
✅ 创建链专属规则: { chainId: 'chain-2', name: '提前达成目标', type: 'early_completion_only' }
✅ 创建链专属规则: { chainId: 'chain-2', name: '特殊情况', type: 'early_completion_only' }

🔍 验证链专属性...
链1专属规则数量: 3
链2专属规则数量: 3
✅ 链专属规则创建成功！

🎉 链专属规则测试完成！
```

## 修复效果

### 修复前
- ❌ 预设规则ID格式错误（"1", "2"）
- ❌ 规则无法保存到存储
- ❌ 规则类型枚举错误
- ❌ 预设规则无法使用
- ❌ 操作重复记录两次
- ❌ 规则是全局的，不同链混在一起
- ❌ "任务完成"和"特殊情况"不可点击

### 修复后
- ✅ 预设规则使用正确的ID格式
- ✅ 规则正确保存到LocalStorage
- ✅ 规则类型枚举正确
- ✅ 预设规则可以正常使用
- ✅ 自动创建默认预设规则
- ✅ 操作只记录一次
- ✅ 规则是链专属的，不同链独立
- ✅ 所有预设规则都可以点击
- ✅ 支持链专属规则创建和管理

## 使用说明

1. **首次使用**：系统会自动为当前链创建默认的预设规则
2. **规则选择**：在暂停或提前完成任务时，可以选择预设规则或创建新规则
3. **规则保存**：所有创建的规则都会自动保存到本地存储
4. **链专属**：每个链的规则都是独立的，不会相互影响
5. **规则管理**：可以通过规则管理器查看和管理所有规则

## 技术细节

- **存储方式**：LocalStorage
- **规则ID格式**：`rule_{timestamp}_{randomString}`
- **规则类型**：`pause_only` 和 `early_completion_only`
- **作用域**：支持链专属规则（`scope: 'chain'`）和全局规则（`scope: 'global'`）
- **缓存机制**：使用ExceptionRuleCache提升性能
- **重复检查**：链专属规则只检查同链内的重复，全局规则检查所有全局规则
